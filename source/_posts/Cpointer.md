---
title: 轻松理解C语言指针
date: 2015-12-30 17:41:40
categories: C语言
---

* ** 前言 **
###### 指针困扰了一些学习编程的人，或许你的老师会告诉你，指针比较难理解。我当时被老师的话唬住所以学习指针那章的时候都没心情听课。（说得像讲别的内容时我听了似的，开玩笑）导致了学习链表的时候各种卧槽。

* ** 基本介绍 **
<!-- more -->
> 《C语言程序设计与实践》中这样写到：程序中数据的使用往往是以变量的形式出现，每个变量都对应若干存储单元，变量的值存储在存储单元中，通过对变量的引用和赋值就可以使用或修改存储在存储单元中的数据。

###### 如果一个变量的地址存放在另一个变量中，则存放地址的变量叫指针变量。
###### 指针并不是指地址，它存放地址。指针运算就是根据指针存放的地址得到那个地址下存放的数据。
###### 常用的是一级指针，二级指针一般比较少用。
<br/>
* ** 较为形象的理解 **
比如：你拿着一张纸，纸上写着A214，让你去教学楼A214教室找一个人a，A214就是这个人所在的地址，你拿着的纸就相当于一个一级指针，你有地址，你就能找到这个人。  <br/><br/>类似的，二级指针则是：纸上写的A214教室里没有这个人，但是门上贴着另一个地址：A215，然后你来到A215，找到了这个人，那么这张纸就相当于一个二级指针。  <br/><br/>因为你要经过两次寻找，才能找到这个人。

- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

* ** 指针的声明及初始化 **
```C
#include <stdio.h>
int main()
{
	int x,y;
    int *px,*py,*p;
    px = &x;  // &是取地址符号
    py = &y;
    x = 21;
    y = *px;
//  指针运算，即取出 px 这个地址（也就是 x 的地址）对应的值赋给 y
   	p = &y;
    printf("%d,%d,%d,%d,%d\n",*px,*py,x,y,*p);
   	return 0;
}

 /*  输出结果:分别是对 px 做指针运算得到的21,对 py 做指针运算得到的
 21,x的值21,y的值21,对p做指针运算得到y的值21  */
```

<br/>

* ** 包含指针运算的一段简单的代码 **
```C
#include <stdio.h>
int main()
{
    int x,y;
    int *px,*py,*p;
    px = &x;  // &是取地址符号
    py = &y;
    x = 21;
    y = *px;
//  指针运算，即取出 px 这个地址（也就是 x 的地址）对应的值赋给 y

   	p = &y;
    printf("%d,%d,%d,%d,%d\n",*px,*py,x,y,*p);
    return 0;
}

   /*  输出结果:分别是对 px 做指针运算得到的21, 对 py 做指针运算得到的21, x的值21, y的值21, 对p做指针运算得到y的值21  */  
```

<br/>

* ** 注意事项 **
> 1> 指针不能指向一个没有被定义的变量，这也是第一行代码存在的原因。
> 2> 指针不能指向具体的数值，例如：int *p = 3，这是错误的。
> 3> 分清楚当前指针是在做指针运算还是表明该指针指向某个变量。

*第三条个人认为非常重要，不然有时会懵逼，不要一看到 `* `号就觉得是在做指针运算（即把那个地址下的值给取出来），因为有的时候只是表明那个变量的指针身份，表指向而已。*

- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

* ** 指针与数组 **
> 数组的名字就是它的首地址，这个首地址是不能被改变的，数组可以转换成指针。

```C
	int a[3];
	for(int i = 0; i<3; i++)
	{
		*(a+i) = i;
	//  *(a) = i; a++;  这样写是错误的，a是指针常量，常量不能被修改
	}
```

<br/>

* ** 指针常量 **
> 形如：int * const pa = a;
> 仔细观察一下，*号在const前面，说明pa是常量。

```C
	int a = 1;
	int b = 3;
	int *const pa = &a;
	a = b;   //  这句话也可以用*pa = b来代替

//  如果写 pa = &b 显然是不行的，因为pa这个指针是常量指针
	printf("%d",*pa);

//  输出结果是3
```

<br/>

* ** 常量指针 **
> 形如：int const *pa = a;
> 这里int和const谁前谁后都是一样的

```C
int a = 2;
int b = 3;
const int *pi = &a; //仔细观察可以看出 pi 是指向常量的指针
pi=&b;　　　  //注意这里，pi可以在任意时候重新赋值一个新内存地址
b = 30;　　　 //如果这里用*pi=30,是错误的
printf( “%d”, *pi ) ;

// 输出是30

```
有人会疑惑, 这明明是指向常量的指针, 为什么指向的那个数据却从2变成了30?

这是因为pi存的地址是可以变的，其实只是说不能直接写*pi = xxxx 而已，不能这样改变，但是可以用别的方式改变。

对比上面两端代码看看，应该就明白了。

<br/>

* ** 为什么指针变量要分类型 **
> 疑惑：如果初始化指针指向一个已经声明过的变量，是不是可以不用写指针类型?因为指针类型就是它指向的数据的类型?

```C
int a = 3;
char ch = 1; //如果这里写'1'后面会输出49，因为是ASCII码，ASCII码中的字符1对应十进制49

char *p = &ch;
printf("%d",*p);
```
是这样：指针的指向类型决定这个指针会读多少个字节的数据出来。

至于怎么读，从低往高读还是从高往低读，数据存储是从高到低还是从低到高，
想了解的话可以到这里看(不知道链接是否还有效)：

- [数据变量在内存中的存储方式](http://blog.sina.com.cn/s/blog_abc091cc0101h0a3.html)
- [堆区，栈区，静态存储区详解](http://my.oschina.net/lxrm/blog/513794)

声明了类型会安全很多。

p读取一个字节的数据，也就是ch的内容 ：1

然而如果把第四行改成`int *p = &ch`，最后输出的就不一定是1了，这要看内存分配，这个指针会读取4个字节（32位平台下int型占4个字节）的数据，非常危险。

<br/>

* ** 指针在函数中的运用 `值传递` **

```C
#include <stdio.h>

void fun(int a1,int b1)
{
    int temp = a1;
    a1 = b1;
    b1 = temp;
}

int main()
{
    int a = 3;b = 4;
    fun(a,b);
    printf("%d %d",a,b);
    return 0;
}

输出结果：3 4
a1 = 4,b1 = 3,a = 3,b = 4
```

观察这个函数，简洁明了啊，就是把两个参数交换。但是为什么后面的输出并没有把a，b的值交换？
是因为：在给函数传递参数的时候，隐式地做了赋值，把调用函数那一句话括号里面的参数赋给了形参。

fun(a,b);
//相当于 a1 = a; b1 = b;

进入函数以后，操作数是被赋值过后的a1和b1，所以只是把被a,b分别赋值后的a1,b1作交换，并不是a,b。

这是初次学习函数的人常常犯的错误。

<br/>

* ** 指针在函数中的运用 `地址传递` **

```C
#include <stdio.h>

void fun(int *pa,int *pb)
{
    int temp = *pa;
    *pa = *pb;
    *pb = temp;
}

int main()
{
    int a=3,b = 4;
    fun(&a,&b);
    printf("%d %d",a,b);
    return 0;
}

输出结果：4 3
```
传给函数作为参数的是a,b的地址，pa = &a, pb = &b，从这两个地址下取出来的值*pa,*pb当然就是a,b的值了。

然后再交换，所以交换成功。

<br/>

* ** 指针在函数中的运用 `引用传递` **（C++的概念）

```C
void fun(int &a,int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

int main()
{
    int a = 3,b = 4;
    fun(a,b);
    printf("%d %d",a,b);
    return 0;
}

运行结果：4 3
```
> 这段代码在DEVC++环境下(codeblock也是这样，别的环境我没有试过），如果选择建立.c而不是.cpp文件，使用引用传递会报错

这三段代码中的第二段可以视作是C语言的模拟引用传递


<br/>

* ** 指向函数的指针 **
某一数据变量的内存地址可以存储在相应的指针变量中，函数的首地址也可以存储在某个函数指针变量里，这样就可以通过这个函数指针变量来调用所指向的函数。

函数指针变量和别的变量一样，也是需要声明后才能用的，相似于函数void fun(int)的声明，指向这个函数的指针要写成void (*pfun)(int)

于是：
```
	void fun(int);
    void (*pFun)(int);

```
这两行就完成了一个函数指针的声明。

```C

#include <stdio.h>

void fun(int x)  // 如果此处只是声明，不写实现，x可以不写，只用写参数数据类型
{
    printf("%d\n",x);
}

int main()
{
    void (*pFun)(int); //括号内也可以写int x
    pFun = &fun;   // 令pFun函数指针指向fun函数
    fun(10);    // 直接调用函数 
    (*pFun)(20) ;   //  通过指针调用函数
    return 0;
}

运行结果：   10
			 20

```

<br/>

> 看到这里，希望觉得自己不懂指针的人会感觉指针并不是那么难懂，我能写出来的都还是很浅层次的内容。
